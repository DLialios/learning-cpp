#include <iostream>
#include <vector>
#include <string>
#include <exception>
#include "foo.hpp"
#include "yoda.hpp"

namespace AutoGenerated
{
    // if you define a ctor that is not default,
    // then a default ctor is not generated

    struct S
    {
        std::vector<int> v;
        int i;
    };

    void func()
    {
        S s1;                   // default ctor
        S s2 = s1;              // copy ctor
        S s3 = std::move(s2);   // move ctor

        S s4, s5;
        s4 = s5;                //copy assignment
        s4 = std::move(s5);     //move assignment
    }
}

void init_the_ones()
{
    //    int x1 = 1;
    //    int x2(1);
    //    int x3{1};
    //    int x4 = int(1);
    //    int x5(int(1));
    //    int x6{int(1)};
    //    int x7 = int{1};
    //    int x8(int{1});
    //    int x9{int{1}};
    //    auto x10 = 1;
    //    auto x11(1);
    //    auto x13{1};
    //    auto x14 = int(1);
    //    auto x15(int(1));
    //    auto x16{int(1)};
    //    auto x17 = int{1};
    //    auto x18(int{1});
    //    auto x19{int{1}};
}

void constructor_tests()
{
    using Foo::Bar;
    Bar baz0{};
    Bar baz1(4);
    //  Bar baz2 = 4;
    /* attempts to materialize a temporary
       using a non-explicit constructor */
    Bar baz3{1,2,3,4};
    Bar baz4 = {1,2,3,4};
}

void copy_constructor_tests()
{
    using Foo::Bar;
    Bar baz0;
    Bar baz1(baz0);
    Bar baz2 = baz0;
    Bar baz3{baz0};
    Bar baz4 = {baz0};
}

void copy_assignment_tests()
{
    using Foo::Bar;
    Bar baz0;
    Bar baz1;
    baz0 = baz1;
}

void vtbl_stuff()
{
    std::cout<<sizeof(yoda::Bar)<<std::endl; // 16
    yoda::Bar b, b2;
    int* ptr = reinterpret_cast<int*>(&b);     
    std::cout<<*(ptr+2)<<std::endl; // should print 3
    // **** **** **** 0000 O
    // O is the stride addr

    //is the vtable addr for any given type the same?
    //yes.
    unsigned char* r = reinterpret_cast<unsigned char*>(&b);     
    unsigned char* r2 = reinterpret_cast<unsigned char*>(&b2);     
    std::cout<<"0x";
    for (int i = 5; i >= 0; --i)
        printf("%02x", r[i]);
    std::cout<<std::endl<<"0x";
    for (int i = 5; i >= 0; --i)
        printf("%02x", r2[i]);
    std::cout<<std::endl;
    ////
    yoda::Foo* foo = new yoda::Baz;
    yoda::Foo* foo2 = new yoda::Bar;
    unsigned char* point = reinterpret_cast<unsigned char*>(foo);     
    unsigned char* point2 = reinterpret_cast<unsigned char*>(foo2);     
    std::cout<<"0x";
    for (int i = 5; i >= 0; --i)
        printf("%02x", point[i]);
    std::cout<<std::endl<<"0x";
    for (int i = 5; i >= 0; --i)
        printf("%02x", point2[i]);
    std::cout<<std::endl;
    delete foo;
    delete foo2;
}

void throw_test()
{
    try {
        throw Foo::Bar{1,2,3,4};
    } catch (const Foo::Bar& e) {
        std::cout << e[1] << std::endl;
    }
}

void throw_test2()
{
    std::vector v {42,42};
    try {
        std::cout << v.at(v.size());
    } catch (const std::exception& e) {
        std::cerr << e.what() << '\n';
    }
    /* catch-all
     * catch(...) {}
     */
}

void udl()
{
    using namespace Foo;
    //Bar b{64.5_bar+12.3_bar};
    //versus
    Bar b(64.5_bar+12.3_bar);
    std::cout<<b<<std::endl;
}

void runner() {
}

int main(int argc, const char** argv) 
{
    std::cout<<"Hello from main"<<std::endl;
    std::cout<<"argc: "<<argc<<std::endl;
    std::string args;
    for (int i = 0; i < argc - 1; ++i) {
        args.append(std::string(argv[i]) + ", ");
    }
    args.append(argv[argc - 1]);
    std::cout<<"argv: "<<args<<std::endl;
    std::cout<<"PWD: "<<std::getenv("PWD")<<std::endl;
    std::cout<<"########################"<<std::endl;
    runner();
    std::cout<<"########################"<<std::endl;
    std::cout<<"Goodbye from main"<<std::endl;
    return 0;
}
