superfluous parentheses around function param declarations
int f(int (a)) {} <--> int f(int a) {}
int i(int(x)); // vexing parse
int i(int());  // vexing parse

reference-qualified member functions

const pointer vs pointer to const

declare/define vs initialize/assign

qualified vs unqualified names
qualified names include an associated scope
C::s_member; // s_member is qualified by class C
obj.x;	     // x is qualified by class object obj
ptr->y;	     // y is qualified by pointer to class object ptr

using declaration vs using directive
  using declaration 
    inject declarations into curr scope
  using directive 
    inject declarations into lowest common ancestor

argument-dependent lookup
0. look in curr namespace for matching name
1. check for declaration of: 
     - class member with same name
     - func at block scope that's not a using-declaration
2. use ADL
3. resort to fallback e.g. using std::swap

lifetime extension of temporaries via rval refs
  auto vars in func scope are destroyed after
  ret val placeholder is all set; careful
  with returning dangling references

dynamic	    cast
static	    cast
reinterpret cast
const	    cast
    dynamic ->	only casts to reference type throw
		Does this polymorphic object have the
		given class in its hierarchy?

int(3) vs (int)3

obj->x;
obj.operator->()->x;
if ret val is another object of class type (not a ptr),
then chain operator->() calls until one returns a pointer

range-for semantics
Container c;
for (auto i : c)
    foo(i);
||||||||||||||||||
VVVVVVVVVVVVVVVVVV
for (auto it = c.begin(), end = c.end(); it != end; ++it) { 
    auto i = *it; 
    foo(i);
}

default	    init
value	    init
direct	    init
copy	    init
list	    init
aggregate   init
reference   init

dynamic dispatch through vtables

inheritance access modifiers

one unambiguous implicit conversion sequence from T1 to T2

eval order of func args is unspecified

smart pointers: unique_ptr, shared_ptr, weak_ptr

only lambdas without captures decay to function pointers
trailing returns on lambdas

conversion constructor vs conversion function;explicit keyword

compiler-generated func: =delete and =default

Rule of Zero: If you can avoid defining default operations, do
Rule of Five: If you define or =delete any copy, move, or 
              destructor function, define or =delete them all

CTOR
1) CTOR args
2) base class constructor
3) constructor member initializer list; 
   use default member initializers if missing 
4) CTOR body

default member initializers do not allow () form 

DTOR
1) DTOR body
2) run DTORs of each class member
3) invoke DTOR of parent class

new/delete expressions
    operator new() then CTOR
    DTOR then operator delete() 

placement new
::new(placement-params) type|initializer

deconstruct vs deallocate 

use RAII to achieve strong resource safety
    eliminate resource leaks for a 
    general notion of a resource
    (memory, locks, sockets, file&thread handles)

pointers to member functions
    unsigned (Bar::*ptr)() const = &yoda::Bar::roll;

const type qualifier is useless on func ret type

A “template function” is the instantiation of a “function template”

A template's declaration and definition must be in scope for use

CTAD does not exist prior to c++17

explicit template instantiation 
    explicit parameterized type instantiation
	template class Foo<std::string>;
    explicit function template instantiation
	template void print<std::string>(std::string);
full specialization does instantiate

typename vs class 
- specifying a template: same
- use typename for dependent names
- use class for template template (< c++17)

template function overload resolution
- nontemplate functions = first-class citizens
- if there is a suitable base function template use it
- if a specialization exists (for this base) for the
  types being used then use it

template param pack vs function param pack
parameter packs indicate a sequence of length sizeof...(pack)
pack expansion on a pattern f(g(pack)...);

fold types:
- unary right fold (vals + ...) becomes 
  (vals[0] + (... + (vals[N-1] + vals[N])))
- unary left fold (... + vals) becomes
  (((vals[0] + vals[1]) + ...) + vals[N])
- binary right fold (vals + ... + 0) becomes
  (vals[0] + (... + (vals[N-1] + (vals[N] + 0))))
- binary left fold (0 + ... + vals) becomes
  ((((0 + vals[0]) + vals[1]) + ...) + vals[N])

templates
    class
    function
    alias
    variable
    deduction guides

if constexpr() and noexcept() for compile-time code gen
 
using vs typedef vs namespace
- alias templates only work with 'using'
- typedefs are technically init-statements

all expr have a type and value category
    p(ure)rvalue lvalue x(piring)value 

string literals are lvalues because of their loc in data segment
auto str = "hello";	--> str is const char*
auto& str = "hello";	--> str is const char &[6]

decltype(e)
    - parenthesis => 'treat this as an expression instead of an entity'
    - if the value category of expression is prvalue,
      then decltype yields T
    - if the value category of expression is lvalue,
      then decltype yields T&
    - if the value category of expression is xvalue, 
      then decltype yields T&&

universal refs & type deduction
    ignore top-level cv-qualifiers for P and A
    deduced type is always the referenced type
    (except when P is universal ref and A is lvalue)

******************************

A template argument for which a concept is specified is
called a constrained argument and a template for which 
an argument is constrained is called a constrained template.

Substitution failure is not an error (SFINAE)

using auto&& in range-for because of iterator returning a proxy reference

C++ templates are a compile-time version of duck typing

requires-expressions vs. requires-clauses
A concept is a compile-time predicate specifying how one or more types 
can be used.

Template template parameters can also be constrained. In this case argument
must be less or equally constrained than parameter. Unconstrained template
template parameters still can accept constrained templates as arguments

member functions with unsatisfied constraints become invisible
template<typename T>
struct X{
    void f() requires std::integral<T>
    {}
};

an auto keyword in a template parameter can be used to indicate a non-type
parameter, the type of which is deduced at the point of instantiation
template<is_sortable auto NonTypeParameter, is_sortable TypeParameter>

We omit the first concept parameter when using the inline syntax 
(either with auto or a template)


default vs. value initialization
if you define a default constructor, it will be called regardless
int x;
int* x = new int;
int x{};
int* x = new int();

ordinary member functions get 3 things:
1 access to internals of class
2 are in the scope of the class
3 must be invoked on an instance
-->friends get only 1
-->static functions get 1 and 2


use std::list where you need to insert/erase elements and not invalidate
iterators. std::vector invalidates all iterators on insert and erase.
std::list guarantees that iterators to existing elements are still 
valid 

use find() and insert() for maps instead of [] if you don't want to
add default values for unknown keys

use std::map if order is required, else std::unordered_map is
likely better

std::unordered_set is nearly identical to std::unordered_map 
except that it only contains keys and no values

Creating a new hash function by combining existing hash functions 
using exclusive-or (ˆ) is simple and often very effective
namespace std { // make a hash function for Record
    template<> 
        struct hash<Record> {
            using argument_type = Record;
            using result_type = std::size_t;
            size_t operator()(const Record& r) const
            {
                return hash<string>()(r.name) ˆ hash<int>()(r.product_code);
            }
        };
}

use std::deque for stacks/queues or a suitable adaptor

A standard algorithm is expressed in terms of (half-open) 
sequences of elements. A sequence is represented by a pair 
of iterators specifying the first element and the one-beyond
-the-last element

sort,binary_search
find
begin,rbegin,cbegin,crbegin,advance
back_inserter,front_inserter

Iterators are used to separate algorithms and containers. An
algorithm operates on its data through iterators and knows nothing
about the container in which the elements are stored. Conversely,
a container knows nothing about the algorithms operating on its
elements; all it does is to supply iterators upon request (e.g.,
begin() and end()). This model of separation between data storage
and algorithm delivers very general and flexible software.

Input iterators are used in pairs representing a sequence
