superfluous parentheses around function param declarations
int f(int (a)) {} <--> int f(int a) {}
int i(int(x)); // vexing parse
int i(int());  // vexing parse

reference-qualified member functions

const pointer vs pointer to const

declare/define vs initialize/assign

qualified vs unqualified names
qualified names include an associated scope
C::s_member; // s_member is qualified by class C
obj.x;	     // x is qualified by class object obj
ptr->y;	     // y is qualified by pointer to class object ptr

using declaration vs using directive
  using declaration 
    inject declarations into curr scope
  using directive 
    inject declarations into lowest common ancestor

argument-dependent lookup
0. look in curr namespace for matching name
1. check for declaration of: 
     - class member with same name
     - func at block scope that's not a using-declaration
2. use ADL
3. resort to fallback e.g. using std::swap

lifetime extension of temporaries via rval refs
  auto vars in func scope are destroyed after
  ret val placeholder is all set; careful
  with returning dangling references

dynamic	    cast
static	    cast
reinterpret cast
const	    cast
    dynamic ->	only casts to reference type throw
		Does this polymorphic object have the
		given class in its hierarchy?

int(3) vs (int)3

default	    init
value	    init
direct	    init
copy	    init
list	    init
aggregate   init
reference   init

dynamic dispatch through vtables

inheritance access modifiers

one unambiguous implicit conversion sequence from T1 to T2

eval order of func args is unspecified

smart pointers: unique_ptr, shared_ptr, weak_ptr

only lambdas without captures decay to function pointers
trailing returns on lambdas

conversion constructor vs conversion function;explicit keyword

compiler-generated func: =delete and =default

Rule of Zero: If you can avoid defining default operations, do
Rule of Five: If you define or =delete any copy, move, or 
              destructor function, define or =delete them all

CTOR
1) CTOR args
2) base class constructor
3) constructor member initializer list; 
   use default member initializers if missing 
4) CTOR body

default member initializers do not allow () form 

DTOR
1) DTOR body
2) run DTORs of each class member
3) invoke DTOR of parent class

new/delete expressions
    operator new() then CTOR
    DTOR then operator delete() 

placement new
::new(placement-params) type|initializer

deconstruct vs deallocate 

use RAII to achieve strong resource safety
    eliminate resource leaks for a 
    general notion of a resource
    (memory, locks, sockets, file&thread handles)

pointers to member functions
    unsigned (Bar::*ptr)() const = &yoda::Bar::roll;

A “template function” is the instantiation of a “function template”

CTAD does not exist prior to c++17

explicit template instantiation 
    explicit parameterized type instantiation
	template class Foo<std::string>;
    explicit function template instantiation
	template void print<std::string>(std::string);

typename vs class 
- specifying a template: same
- use typename for dependent names
- use class for template template (< c++17)

template function overload resolution
- nontemplate functions = first-class citizens
- if there is a suitable base function template use it
- if a specialization exists (for this base) for the
  types being used then use it

template param pack vs function param pack
parameter packs indicate a sequence of length sizeof...(pack)
pack expansion on a pattern f(g(pack)...);

fold types:
- unary right fold (vals + ...) becomes 
  (vals[0] + (... + (vals[N-1] + vals[N])))
- unary left fold (... + vals) becomes
  (((vals[0] + vals[1]) + ...) + vals[N])
- binary right fold (vals + ... + 0) becomes
  (vals[0] + (... + (vals[N-1] + (vals[N] + 0))))
- binary left fold (0 + ... + vals) becomes
  ((((0 + vals[0]) + vals[1]) + ...) + vals[N])

templates
    class
    function
    alias
    variable
    deduction guides
 
using vs typedef vs namespace
- alias templates only work with 'using'
- typedefs are technically init-statements


A template argument for which a concept is specified is
called a constrained argument and a template for which 
an argument is constrained is called a constrained template.

Substitution failure is not an error (SFINAE)

every expression has two independent properties:
type and value category

the three primary value categories are:
prvalue lvalue xvalue 
    Pure rvalue refers to an object that is a temporary in the 
    “pure sense": an expression for which the compiler can tell 
    with absolute certainty that its evaluation is an object 
    that is a temporary that has just been created and that is
    immediately expiring (unless we intervene to prolong it’s 
    lifetime by reference binding). The object was created during
    the evaluation of the expression and it will die according to
    the rules of the “mother expression".
    An expiring value is an expression that evaluates to a reference
    to an object that is promised to expire soon. That is it gives
    you a promise that you can do whatever you want to this object
    because it will be destroyed next anyway. But you don’t know 
    when this object was created, or when it is supposed to be 
    destroyed. You just know that you “intercepted" it as it is 
    just about to die.

decltype(e)
    - parenthesis denote 'treat this as an expression instead of an entity'
    - if the value category of expression is prvalue,
      then decltype yields T
    - if the value category of expression is lvalue,
      then decltype yields T&
    - if the value category of expression is xvalue, 
      then decltype yields T&&

The rules of reference collapsing apply when you use references 
to references through one of the following contexts:
    - A decltype specifier
    - A typedef name
    - A template type param
    - Definition of auto variables

const type qualifier is useless on function return types

If a variable or parameter is declared to have type T&& 
for some deduced type T, that variable or parameter is a
universal reference.

Function template argument deduction:
  the special case of forwarding references
    - If P is a reference type, the referenced type is used for deduction
    - If P is an rvalue reference to a cv-unqualified template parameter 
      (so-called forwarding reference), and the corresponding function 
      call argument is an lvalue, the type lvalue reference to A is 
      used in place of A for deduction 

noexcept has its own operator

objects do not have to be referred to by lvalues, they may be
referred to by rvalues; string literals are lvalues

auto str = "hello"; --> str is const char*
auto& str = "hello"; --> str is const char &[6]

typedef int* test;
int a = 3;
const test (&x) = &a;
int* const (&z) = &a;
// x and z have the same type

This ambiguity regarding the lvalueness and rvalueness of what a universal
reference is bound to is the motivation for std::forward to take a universal
reference lvalue and convert it into an rvalue only if the expression it’s
bound to is an rvalue.  The name of the function (“forward”) is an
acknowledgment that our desire to perform such a conversion is virtually always
to preserve the calling argument’s lvalueness or rvalueness when passing –
forwarding – it to another function.

someIterator->f()
someIterator.operator->()->f()
Drill-down behavior: the language chains together operator-> calls until
the last one returns a pointer (this happens only if the return value of 
the overload is an object of class type)

MyContainer c;
for (auto i : c)
    std::cout << i << "\n";
################################
for (auto it = c.begin(), end = c.end(); it != end; ++it) { 
    auto i = *it; 
    std::cout << i << "\n";
}

using auto&& in range-for because of iterator returning a proxy reference

Function objects (functors) used to specify the meaning of key operations 
of a general algorithm are often referred to as policy objects

To use a template, make sure its definition (not just its declaration) 
is in scope

C++ templates are a compile-time version of duck typing

requires-expressions vs. requires-clauses
A concept is a compile-time predicate specifying how one or more types 
can be used.

Template template parameters can also be constrained. In this case argument
must be less or equally constrained than parameter. Unconstrained template
template parameters still can accept constrained templates as arguments

member functions with unsatisfied constraints become invisible
template<typename T>
struct X{
    void f() requires std::integral<T>
    {}
};

an auto keyword in a template parameter can be used to indicate a non-type
parameter, the type of which is deduced at the point of instantiation
template<is_sortable auto NonTypeParameter, is_sortable TypeParameter>

We omit the first concept parameter when using the inline syntax 
(either with auto or a template)


default vs. value initialization
if you define a default constructor, it will be called regardless
int x;
int* x = new int;
int x{};
int* x = new int();

ordinary member functions get 3 things:
1 access to internals of class
2 are in the scope of the class
3 must be invoked on an instance
-->friends get only 1
-->static functions get 1 and 2

It is generally in poor taste to dump every name from a namespace
into the global namespace
All standard-library headers supply declarations in namespace std

use std::list where you need to insert/erase elements and not invalidate
iterators. std::vector invalidates all iterators on insert and erase.
std::list guarantees that iterators to existing elements are still 
valid 

use find() and insert() for maps instead of [] if you don't want to
add default values for unknown keys

use std::map if order is required, else std::unordered_map is
likely better

std::unordered_set is nearly identical to std::unordered_map 
except that it only contains keys and no values

Creating a new hash function by combining existing hash functions 
using exclusive-or (ˆ) is simple and often very effective
namespace std { // make a hash function for Record
    template<> 
        struct hash<Record> {
            using argument_type = Record;
            using result_type = std::size_t;
            size_t operator()(const Record& r) const
            {
                return hash<string>()(r.name) ˆ hash<int>()(r.product_code);
            }
        };
}

use std::deque for stacks/queues or a suitable adaptor

A standard algorithm is expressed in terms of (half-open) 
sequences of elements. A sequence is represented by a pair 
of iterators specifying the first element and the one-beyond
-the-last element

sort,binary_search
find
begin,rbegin,cbegin,crbegin,advance
back_inserter,front_inserter

Iterators are used to separate algorithms and containers. An
algorithm operates on its data through iterators and knows nothing
about the container in which the elements are stored. Conversely,
a container knows nothing about the algorithms operating on its
elements; all it does is to supply iterators upon request (e.g.,
begin() and end()). This model of separation between data storage
and algorithm delivers very general and flexible software.

Input iterators are used in pairs representing a sequence
